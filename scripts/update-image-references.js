/**
 * Image Reference Updater
 * 
 * This script updates image references in your codebase to point to the WebP versions.
 * It reads the mapping file generated by image-processor.js and replaces
 * references in JS, JSX, TS, and TSX files.
 */

const fs = require('fs');
const path = require('path');

// Configuration
const ROOT_DIR = path.join(__dirname, '..');
const MAPPING_FILE = path.join(ROOT_DIR, 'public/image-mapping.json');
const FILE_EXTENSIONS = ['.js', '.jsx', '.ts', '.tsx'];
const EXCLUDE_DIRS = ['node_modules', '.git', '.next'];

// Load the mapping file
let imageMap = {};
try {
  const mappingData = fs.readFileSync(MAPPING_FILE, 'utf8');
  imageMap = JSON.parse(mappingData);
  console.log(`Loaded mapping with ${Object.keys(imageMap).length} entries`);
} catch (error) {
  console.error('Error loading mapping file:', error);
  process.exit(1);
}

/**
 * Walk through directory recursively to find all files
 * @param {string} dir - Directory to walk
 * @param {Function} callback - Callback for each file
 */
function walkDir(dir, callback) {
  if (EXCLUDE_DIRS.includes(path.basename(dir))) return;
  
  fs.readdirSync(dir).forEach(f => {
    const filePath = path.join(dir, f);
    const isDirectory = fs.statSync(filePath).isDirectory();
    
    if (isDirectory) {
      walkDir(filePath, callback);
    } else if (FILE_EXTENSIONS.includes(path.extname(filePath).toLowerCase())) {
      callback(filePath);
    }
  });
}

/**
 * Update image references in a file
 * @param {string} filePath - Path to the file
 */
function updateFileReferences(filePath) {
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    let hasChanges = false;
    
    // Replace all occurrences of old paths with new paths
    for (const [oldPath, newPath] of Object.entries(imageMap)) {
      // Handle different reference patterns
      // 1. Direct path references: "/images/path.png"
      if (content.includes(oldPath)) {
        content = content.replace(new RegExp(oldPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), newPath);
        hasChanges = true;
      }
      
      // 2. Handle references without leading slash: "images/path.png"
      const oldPathNoLeadingSlash = oldPath.substring(1); // Remove leading slash
      const newPathNoLeadingSlash = newPath.substring(1); // Remove leading slash
      if (content.includes(oldPathNoLeadingSlash)) {
        content = content.replace(new RegExp(oldPathNoLeadingSlash.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), newPathNoLeadingSlash);
        hasChanges = true;
      }
      
      // 3. Handle references with dynamic path construction: path.join('/images', 'path.png')
      const oldPathBasename = path.basename(oldPath);
      const newPathBasename = path.basename(newPath);
      if (oldPathBasename !== newPathBasename && content.includes(oldPathBasename)) {
        content = content.replace(new RegExp(`(['"\`])${oldPathBasename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(['"\`])`, 'g'), `$1${newPathBasename}$2`);
        hasChanges = true;
      }
    }
    
    // Only write to file if changes were made
    if (hasChanges) {
      fs.writeFileSync(filePath, content);
      console.log(`Updated references in: ${filePath}`);
    }
  } catch (error) {
    console.error(`Error updating ${filePath}:`, error);
  }
}

/**
 * Main function to update all references
 */
function updateAllReferences() {
  console.log('Starting reference updates...');
  
  // Get all relevant files
  const files = [];
  walkDir(ROOT_DIR, (filePath) => {
    files.push(filePath);
  });
  
  console.log(`Found ${files.length} files to check for image references`);
  
  // Update references in all files
  let updatedCount = 0;
  for (const file of files) {
    const originalContent = fs.readFileSync(file, 'utf8');
    updateFileReferences(file);
    const newContent = fs.readFileSync(file, 'utf8');
    
    if (originalContent !== newContent) {
      updatedCount++;
    }
  }
  
  console.log(`Updated references in ${updatedCount} files`);
  console.log('Reference update complete!');
}

// Run the main function
updateAllReferences();
